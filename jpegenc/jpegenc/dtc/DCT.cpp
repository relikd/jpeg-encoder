#include "DCT.hpp"
#include <math.h>

#define N 8

inline float getC(size_t i) {
	if (i == 0)
		return 0.7071067811865475244008443621048490392848359376884740;  //1/sqrt(2)
	return 1;
}

inline float getConstantC(unsigned char x, unsigned char y) { // (2.0F / N) * getC(i) * getC(j)
	if (x == 0 && y == 0)
		return 0.125;
	else if (x != 0 && y != 0)
		return 0.25;
	else
		return 0.176776695296636893184327732342353556305170059204101562;
}

// float %1.25f  double %1.54f
static const float cos_2x1iPi_2N[8][8] = { // cos( (2x + 1)iπ / 2N )
	{ 1, 0.9807852804032304491261822361342390369739337308933360950031, 0.923879532511286756128183189396788286822416625863642486116, 0.831469612302545237078788377617905756738560811987249963448, 0.707106781186547524400844362104849039284835937688474036591, 0.555570233019602224742830813948532874374937190754804045928, 0.38268343236508977172845998403039886676134456248562704144, 0.19509032201612826784828486847702224092769161775195480776 },
	{ 1, 0.831469612302545237078788377617905756738560811987249963447, 0.38268343236508977172845998403039886676134456248562704144, -0.19509032201612826784828486847702224092769161775195480775, -0.70710678118654752440084436210484903928483593768847403659, -0.980785280403230449126182236134239036973933730893336095002, -0.92387953251128675612818318939678828682241662586364248612, -0.55557023301960222474283081394853287437493719075480404593 },
	{ 1, 0.555570233019602224742830813948532874374937190754804045925, -0.38268343236508977172845998403039886676134456248562704143, -0.980785280403230449126182236134239036973933730893336095003, -0.70710678118654752440084436210484903928483593768847403659, 0.19509032201612826784828486847702224092769161775195480775, 0.92387953251128675612818318939678828682241662586364248611, 0.83146961230254523707878837761790575673856081198724996345 },
	{ 1, 0.195090322016128267848284868477022240927691617751954807755, -0.923879532511286756128183189396788286822416625863642486115, -0.555570233019602224742830813948532874374937190754804045925, 0.707106781186547524400844362104849039284835937688474036587, 0.831469612302545237078788377617905756738560811987249963448, -0.382683432365089771728459984030398866761344562485627041431, -0.980785280403230449126182236134239036973933730893336095004 },
	{ 1, -0.195090322016128267848284868477022240927691617751954807754, -0.923879532511286756128183189396788286822416625863642486115, 0.555570233019602224742830813948532874374937190754804045923, 0.707106781186547524400844362104849039284835937688474036589, -0.831469612302545237078788377617905756738560811987249963445, -0.382683432365089771728459984030398866761344562485627041436, 0.980785280403230449126182236134239036973933730893336095002 },
	{ 1, -0.555570233019602224742830813948532874374937190754804045924, -0.382683432365089771728459984030398866761344562485627041434, 0.980785280403230449126182236134239036973933730893336095003, -0.707106781186547524400844362104849039284835937688474036588, -0.19509032201612826784828486847702224092769161775195480776, 0.923879532511286756128183189396788286822416625863642486116, -0.831469612302545237078788377617905756738560811987249963445 },
	{ 1, -0.831469612302545237078788377617905756738560811987249963446, 0.382683432365089771728459984030398866761344562485627041434, 0.195090322016128267848284868477022240927691617751954807755, -0.707106781186547524400844362104849039284835937688474036589, 0.980785280403230449126182236134239036973933730893336095003, -0.923879532511286756128183189396788286822416625863642486115, 0.55557023301960222474283081394853287437493719075480404592 },
	{ 1, -0.9807852804032304491261822361342390369739337308933360950029, 0.923879532511286756128183189396788286822416625863642486115, -0.831469612302545237078788377617905756738560811987249963446, 0.707106781186547524400844362104849039284835937688474036588, -0.55557023301960222474283081394853287437493719075480404592, 0.38268343236508977172845998403039886676134456248562704143, -0.19509032201612826784828486847702224092769161775195480775 }
};


Mat DCT::transform(Mat input) {
	// As mat has to be quadratic we can just work with the rows
	Mat newMat(input.rows);
	for (int i = 0; i < input.rows; ++i) {
		for (int j = 0; j < input.rows; ++j) {
		
			float outer = 2.0F / input.rows * getC(i) * getC(j);
			float inner = 0;
	
			for (int x = 0; x < input.rows; ++x) {
				for (int y = 0; y < input.rows; ++y) {
					float firstCos = cos(((2 * x + 1) * i * M_PI) / (2.0 * input.rows));
					float secondCos = cos(((2 * y + 1) * j * M_PI) / (2.0 * input.rows));
					inner += input.get(x, y) * firstCos * secondCos;
				}
			}
			newMat.set(i , j , outer * inner);
		}
	}
	
	return newMat;
}

void DCT::transform(float* &input, float* &output, size_t width, size_t height) {
	unsigned char i,j,x,y;
	i = N;
	while (i--) { // outer loop over output
		j = N;
		while (j--) {
			float inner = 0;
			x = N;
			while (x--) { // inner loop over input
				y = N;
				while (y--) {
					inner += input[y + x * N] * cos_2x1iPi_2N[x][i] * cos_2x1iPi_2N[y][j];
				}
			}
			output[j + i * N] = getConstantC(i,j) * inner;
		}
	}
}

Mat DCT::transform2(Mat input) {
	Mat a = generateA(input.rows);
	Mat temp = a * input;
	a.transpose();
	
	return temp * a;
}

Mat DCT::inverse(Mat input) {
	// As mat has to be quadratic we can just work with the rows
	Mat newMat(input.rows);
	
	for (int x = 0; x < input.rows; ++x) {
		for (int y = 0; y < input.rows; ++y) {
			
			float inner = 0;
			
			for (int i = 0; i < input.rows; ++i) {
				for (int j = 0; j < input.rows; ++j) {
					float präfix = 2.0 /input.rows * getC(i) * getC(j) * input.get(i, j);
					float firstCos = cos(((2 * x + 1) * i * M_PI) / (2.0 * input.rows));
					float secondCos = cos(((2 * y + 1) * j * M_PI) / (2.0 * input.rows));
					inner += präfix * firstCos * secondCos;
					
				}
			}
			newMat.set(x, y, inner);
		}
	}
	
	return newMat;
}

Mat DCT::generateA(int dimension) {
	Mat mat(dimension);
	
	for (int k = 0; k < dimension; ++k) {
		for (int n = 0; n < dimension; ++n) {
			float value = getC(k) * sqrt(2.0F / dimension) * cos((2 * n + 1) * ((k * M_PI) / (2 * dimension)));
			mat.set(k, n, value);
		}
	}
	
	return mat;
}
